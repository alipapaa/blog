## go语言逃逸分析

任何时候，一个值被分享到函数栈帧范围之外，它都会在堆上被重新分配，说道这个问题了，我们就谈谈帧边界，这个名词的作用是在函数执行的时候
为了函数的上下文所设置的一个边界，它存在在栈中，栈在 Go 语言中是非常重要的，因为它为分配给每个函数的帧边界提供了物理内存空间，所有又有一个名词叫栈帧
然后有个问题就是在栈的执行过程中，只能执行在这个栈以上的部分，举个例子abc三个函数，a调用b b调用c 那么痛调用机制来说最高的就是a，最低的就是c

举个例子：
栈的就像一个筒子的存钱的东西，你每次需要从下面往上塞硬币，然后用的时候也是从下面往外扣。很形象了哈。

然后在go语言执行的过程中，如果传递的是值就不发生堆的问题了，因为不会指向栈帧边界的下面的问题，因为值被复制到了，为了运行b函数而临时在a中开辟的内存空间里了。不存在和下面的b函数的瓜葛了。

当你使用的是指针，那么复制过去的也是指针，然后你想要使用这个值就要去取栈帧边界下面的东西，但是又不能去得到，怎么办呢，这个时候就需要将下面的这个指针指向的变量存放到堆里，这不就解决了嘛，当然你免不了要gc啊。所以又是资源时间的浪费，如何掂量你自己看着办吧。

```go

package main

type user struct {
    name  string
    email string
}

func main() {
    u1 := createUserV1()
    u2 := createUserV2()

    println("u1", &u1, "u2", &u2)
}

//go:noinline
func createUserV1() user {
    u := user{
        name:  "Bill",
        email: "bill@ardanlabs.com",
    }

    println("V1", &u)
    return u
}

//go:noinline
func createUserV2() *user {
    u := user{// 发生了逃逸分析
        name:  "Bill",
        email: "bill@ardanlabs.com",
    }

    println("V2", &u)
    return &u
}
```

指针指向了栈下的无效地址空间。当 main 函数调用下一个函数，指向的内存将重新映射并将被重新初始化，这就是逃逸分析将开始保持完整性的地方

编译器将检查到，在 createUserV2 的函数栈中构造user值是不安全的，因此，替代地，会在堆中构造相应的值