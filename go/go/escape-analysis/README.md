## go语言逃逸分析

任何时候，一个值被分享到函数栈帧范围之外，它都会在堆上被重新分配，说道这个问题了，我们就谈谈帧边界，这个名词的作用是在函数执行的时候
为了函数的上下文所设置的一个边界，它存在在栈中，栈在 Go 语言中是非常重要的，因为它为分配给每个函数的帧边界提供了物理内存空间，所有又有一个名词叫栈帧
然后有个问题就是在栈的执行过程中，只能执行在这个栈以上的部分，举个例子abc三个函数，a调用b b调用c 那么痛调用机制来说最高的就是a，最低的就是c

举个例子：
栈的就像一个筒子的存钱的东西，你每次需要从下面往上塞硬币，然后用的时候也是从下面往外扣。很形象了哈。

然后在go语言执行的过程中，如果传递的是值就不发生堆的问题了，因为不会指向栈帧边界的下面的问题，因为值被复制到了，为了运行b函数而临时在a中开辟的内存空间里了。不存在和下面的b函数的瓜葛了。

当你使用的是指针，那么复制过去的也是指针，然后你想要使用这个值就要去取栈帧边界下面的东西，但是又不能去得到，怎么办呢，这个时候就需要将下面的这个指针指向的变量存放到堆里，这不就解决了嘛，当然你免不了要gc啊。所以又是资源时间的浪费，如何掂量你自己看着办吧。

```go

package main

type user struct {
    name  string
    email string
}

func main() {
    a1 := createUser1()
    a2 := createUser2()

    fmt.Println("a1", &a1, "a2", &a2)
}

func createUser1() user {
    u := user{
        name:  "Bill",
        email: "@.com",
    }

    fmt.Println("V1", &u)
    return u
}

//go:noinline
func createUser2() *user {
    u := user{// 发生了逃逸分析
        name:  "Bill",
        email: "bill@ardanlabs.com",
    }

    fmt.Println("V2", &u)
    return &u
}
```

指针指向了栈下的无效地址空间。当 main 函数调用下一个函数，指向的内存将重新映射并将被重新初始化，这就是逃逸分析将开始保持完整性的地方

编译器将检查到，在 createUserV2 的函数栈中构造user值是不安全的，因此，替代地，会在堆中构造相应的值

值只有在编译器编译时知道其大小才会将它分配到栈中。这是因为每个函数的栈帧大小是在编译时计算的。如果编译器不知道其大小，就只会在堆中分配。
例如有一个数组你没有给它分配大小，那么它就没办法放到栈里就会放到堆里。

总结：

- 当函数执行的时候无法执行**帧边界**下面的部分就会发生将数据推入堆的逃逸分析
- 当分配的数据，程序无法知道具体的大小的时候就会放到堆里

     > 例如一个不知道大小的map或者一个不知道大小的slice。

逃逸分析的可怕之处就是造成大量的gc，因为堆的数据垃圾回收是go通过gc来回收的。
